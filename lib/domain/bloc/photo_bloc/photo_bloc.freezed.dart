// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'photo_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$PhotoEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getPhotos,
    required TResult Function() fetchPhotos,
    required TResult Function() getPhotosFromLocal,
    required TResult Function(PhotoModel photo) removePhotoFromLocal,
    required TResult Function(PhotoModel photo) setPhotoToLocal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getPhotos,
    TResult? Function()? fetchPhotos,
    TResult? Function()? getPhotosFromLocal,
    TResult? Function(PhotoModel photo)? removePhotoFromLocal,
    TResult? Function(PhotoModel photo)? setPhotoToLocal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getPhotos,
    TResult Function()? fetchPhotos,
    TResult Function()? getPhotosFromLocal,
    TResult Function(PhotoModel photo)? removePhotoFromLocal,
    TResult Function(PhotoModel photo)? setPhotoToLocal,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetPhotos value) getPhotos,
    required TResult Function(_FetchPhotos value) fetchPhotos,
    required TResult Function(_GetPhotosFromLocal value) getPhotosFromLocal,
    required TResult Function(_RemovePhotoFromLocal value) removePhotoFromLocal,
    required TResult Function(_SetPhotoToLocal value) setPhotoToLocal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetPhotos value)? getPhotos,
    TResult? Function(_FetchPhotos value)? fetchPhotos,
    TResult? Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult? Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult? Function(_SetPhotoToLocal value)? setPhotoToLocal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetPhotos value)? getPhotos,
    TResult Function(_FetchPhotos value)? fetchPhotos,
    TResult Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult Function(_SetPhotoToLocal value)? setPhotoToLocal,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PhotoEventCopyWith<$Res> {
  factory $PhotoEventCopyWith(
          PhotoEvent value, $Res Function(PhotoEvent) then) =
      _$PhotoEventCopyWithImpl<$Res, PhotoEvent>;
}

/// @nodoc
class _$PhotoEventCopyWithImpl<$Res, $Val extends PhotoEvent>
    implements $PhotoEventCopyWith<$Res> {
  _$PhotoEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$_GetPhotosCopyWith<$Res> {
  factory _$$_GetPhotosCopyWith(
          _$_GetPhotos value, $Res Function(_$_GetPhotos) then) =
      __$$_GetPhotosCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GetPhotosCopyWithImpl<$Res>
    extends _$PhotoEventCopyWithImpl<$Res, _$_GetPhotos>
    implements _$$_GetPhotosCopyWith<$Res> {
  __$$_GetPhotosCopyWithImpl(
      _$_GetPhotos _value, $Res Function(_$_GetPhotos) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_GetPhotos implements _GetPhotos {
  const _$_GetPhotos();

  @override
  String toString() {
    return 'PhotoEvent.getPhotos()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GetPhotos);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getPhotos,
    required TResult Function() fetchPhotos,
    required TResult Function() getPhotosFromLocal,
    required TResult Function(PhotoModel photo) removePhotoFromLocal,
    required TResult Function(PhotoModel photo) setPhotoToLocal,
  }) {
    return getPhotos();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getPhotos,
    TResult? Function()? fetchPhotos,
    TResult? Function()? getPhotosFromLocal,
    TResult? Function(PhotoModel photo)? removePhotoFromLocal,
    TResult? Function(PhotoModel photo)? setPhotoToLocal,
  }) {
    return getPhotos?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getPhotos,
    TResult Function()? fetchPhotos,
    TResult Function()? getPhotosFromLocal,
    TResult Function(PhotoModel photo)? removePhotoFromLocal,
    TResult Function(PhotoModel photo)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (getPhotos != null) {
      return getPhotos();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetPhotos value) getPhotos,
    required TResult Function(_FetchPhotos value) fetchPhotos,
    required TResult Function(_GetPhotosFromLocal value) getPhotosFromLocal,
    required TResult Function(_RemovePhotoFromLocal value) removePhotoFromLocal,
    required TResult Function(_SetPhotoToLocal value) setPhotoToLocal,
  }) {
    return getPhotos(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetPhotos value)? getPhotos,
    TResult? Function(_FetchPhotos value)? fetchPhotos,
    TResult? Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult? Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult? Function(_SetPhotoToLocal value)? setPhotoToLocal,
  }) {
    return getPhotos?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetPhotos value)? getPhotos,
    TResult Function(_FetchPhotos value)? fetchPhotos,
    TResult Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult Function(_SetPhotoToLocal value)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (getPhotos != null) {
      return getPhotos(this);
    }
    return orElse();
  }
}

abstract class _GetPhotos implements PhotoEvent {
  const factory _GetPhotos() = _$_GetPhotos;
}

/// @nodoc
abstract class _$$_FetchPhotosCopyWith<$Res> {
  factory _$$_FetchPhotosCopyWith(
          _$_FetchPhotos value, $Res Function(_$_FetchPhotos) then) =
      __$$_FetchPhotosCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_FetchPhotosCopyWithImpl<$Res>
    extends _$PhotoEventCopyWithImpl<$Res, _$_FetchPhotos>
    implements _$$_FetchPhotosCopyWith<$Res> {
  __$$_FetchPhotosCopyWithImpl(
      _$_FetchPhotos _value, $Res Function(_$_FetchPhotos) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_FetchPhotos implements _FetchPhotos {
  const _$_FetchPhotos();

  @override
  String toString() {
    return 'PhotoEvent.fetchPhotos()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_FetchPhotos);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getPhotos,
    required TResult Function() fetchPhotos,
    required TResult Function() getPhotosFromLocal,
    required TResult Function(PhotoModel photo) removePhotoFromLocal,
    required TResult Function(PhotoModel photo) setPhotoToLocal,
  }) {
    return fetchPhotos();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getPhotos,
    TResult? Function()? fetchPhotos,
    TResult? Function()? getPhotosFromLocal,
    TResult? Function(PhotoModel photo)? removePhotoFromLocal,
    TResult? Function(PhotoModel photo)? setPhotoToLocal,
  }) {
    return fetchPhotos?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getPhotos,
    TResult Function()? fetchPhotos,
    TResult Function()? getPhotosFromLocal,
    TResult Function(PhotoModel photo)? removePhotoFromLocal,
    TResult Function(PhotoModel photo)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (fetchPhotos != null) {
      return fetchPhotos();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetPhotos value) getPhotos,
    required TResult Function(_FetchPhotos value) fetchPhotos,
    required TResult Function(_GetPhotosFromLocal value) getPhotosFromLocal,
    required TResult Function(_RemovePhotoFromLocal value) removePhotoFromLocal,
    required TResult Function(_SetPhotoToLocal value) setPhotoToLocal,
  }) {
    return fetchPhotos(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetPhotos value)? getPhotos,
    TResult? Function(_FetchPhotos value)? fetchPhotos,
    TResult? Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult? Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult? Function(_SetPhotoToLocal value)? setPhotoToLocal,
  }) {
    return fetchPhotos?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetPhotos value)? getPhotos,
    TResult Function(_FetchPhotos value)? fetchPhotos,
    TResult Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult Function(_SetPhotoToLocal value)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (fetchPhotos != null) {
      return fetchPhotos(this);
    }
    return orElse();
  }
}

abstract class _FetchPhotos implements PhotoEvent {
  const factory _FetchPhotos() = _$_FetchPhotos;
}

/// @nodoc
abstract class _$$_GetPhotosFromLocalCopyWith<$Res> {
  factory _$$_GetPhotosFromLocalCopyWith(_$_GetPhotosFromLocal value,
          $Res Function(_$_GetPhotosFromLocal) then) =
      __$$_GetPhotosFromLocalCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_GetPhotosFromLocalCopyWithImpl<$Res>
    extends _$PhotoEventCopyWithImpl<$Res, _$_GetPhotosFromLocal>
    implements _$$_GetPhotosFromLocalCopyWith<$Res> {
  __$$_GetPhotosFromLocalCopyWithImpl(
      _$_GetPhotosFromLocal _value, $Res Function(_$_GetPhotosFromLocal) _then)
      : super(_value, _then);
}

/// @nodoc

class _$_GetPhotosFromLocal implements _GetPhotosFromLocal {
  const _$_GetPhotosFromLocal();

  @override
  String toString() {
    return 'PhotoEvent.getPhotosFromLocal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_GetPhotosFromLocal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getPhotos,
    required TResult Function() fetchPhotos,
    required TResult Function() getPhotosFromLocal,
    required TResult Function(PhotoModel photo) removePhotoFromLocal,
    required TResult Function(PhotoModel photo) setPhotoToLocal,
  }) {
    return getPhotosFromLocal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getPhotos,
    TResult? Function()? fetchPhotos,
    TResult? Function()? getPhotosFromLocal,
    TResult? Function(PhotoModel photo)? removePhotoFromLocal,
    TResult? Function(PhotoModel photo)? setPhotoToLocal,
  }) {
    return getPhotosFromLocal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getPhotos,
    TResult Function()? fetchPhotos,
    TResult Function()? getPhotosFromLocal,
    TResult Function(PhotoModel photo)? removePhotoFromLocal,
    TResult Function(PhotoModel photo)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (getPhotosFromLocal != null) {
      return getPhotosFromLocal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetPhotos value) getPhotos,
    required TResult Function(_FetchPhotos value) fetchPhotos,
    required TResult Function(_GetPhotosFromLocal value) getPhotosFromLocal,
    required TResult Function(_RemovePhotoFromLocal value) removePhotoFromLocal,
    required TResult Function(_SetPhotoToLocal value) setPhotoToLocal,
  }) {
    return getPhotosFromLocal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetPhotos value)? getPhotos,
    TResult? Function(_FetchPhotos value)? fetchPhotos,
    TResult? Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult? Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult? Function(_SetPhotoToLocal value)? setPhotoToLocal,
  }) {
    return getPhotosFromLocal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetPhotos value)? getPhotos,
    TResult Function(_FetchPhotos value)? fetchPhotos,
    TResult Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult Function(_SetPhotoToLocal value)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (getPhotosFromLocal != null) {
      return getPhotosFromLocal(this);
    }
    return orElse();
  }
}

abstract class _GetPhotosFromLocal implements PhotoEvent {
  const factory _GetPhotosFromLocal() = _$_GetPhotosFromLocal;
}

/// @nodoc
abstract class _$$_RemovePhotoFromLocalCopyWith<$Res> {
  factory _$$_RemovePhotoFromLocalCopyWith(_$_RemovePhotoFromLocal value,
          $Res Function(_$_RemovePhotoFromLocal) then) =
      __$$_RemovePhotoFromLocalCopyWithImpl<$Res>;
  @useResult
  $Res call({PhotoModel photo});
}

/// @nodoc
class __$$_RemovePhotoFromLocalCopyWithImpl<$Res>
    extends _$PhotoEventCopyWithImpl<$Res, _$_RemovePhotoFromLocal>
    implements _$$_RemovePhotoFromLocalCopyWith<$Res> {
  __$$_RemovePhotoFromLocalCopyWithImpl(_$_RemovePhotoFromLocal _value,
      $Res Function(_$_RemovePhotoFromLocal) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? photo = null,
  }) {
    return _then(_$_RemovePhotoFromLocal(
      photo: null == photo
          ? _value.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as PhotoModel,
    ));
  }
}

/// @nodoc

class _$_RemovePhotoFromLocal implements _RemovePhotoFromLocal {
  const _$_RemovePhotoFromLocal({required this.photo});

  @override
  final PhotoModel photo;

  @override
  String toString() {
    return 'PhotoEvent.removePhotoFromLocal(photo: $photo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_RemovePhotoFromLocal &&
            (identical(other.photo, photo) || other.photo == photo));
  }

  @override
  int get hashCode => Object.hash(runtimeType, photo);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_RemovePhotoFromLocalCopyWith<_$_RemovePhotoFromLocal> get copyWith =>
      __$$_RemovePhotoFromLocalCopyWithImpl<_$_RemovePhotoFromLocal>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getPhotos,
    required TResult Function() fetchPhotos,
    required TResult Function() getPhotosFromLocal,
    required TResult Function(PhotoModel photo) removePhotoFromLocal,
    required TResult Function(PhotoModel photo) setPhotoToLocal,
  }) {
    return removePhotoFromLocal(photo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getPhotos,
    TResult? Function()? fetchPhotos,
    TResult? Function()? getPhotosFromLocal,
    TResult? Function(PhotoModel photo)? removePhotoFromLocal,
    TResult? Function(PhotoModel photo)? setPhotoToLocal,
  }) {
    return removePhotoFromLocal?.call(photo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getPhotos,
    TResult Function()? fetchPhotos,
    TResult Function()? getPhotosFromLocal,
    TResult Function(PhotoModel photo)? removePhotoFromLocal,
    TResult Function(PhotoModel photo)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (removePhotoFromLocal != null) {
      return removePhotoFromLocal(photo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetPhotos value) getPhotos,
    required TResult Function(_FetchPhotos value) fetchPhotos,
    required TResult Function(_GetPhotosFromLocal value) getPhotosFromLocal,
    required TResult Function(_RemovePhotoFromLocal value) removePhotoFromLocal,
    required TResult Function(_SetPhotoToLocal value) setPhotoToLocal,
  }) {
    return removePhotoFromLocal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetPhotos value)? getPhotos,
    TResult? Function(_FetchPhotos value)? fetchPhotos,
    TResult? Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult? Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult? Function(_SetPhotoToLocal value)? setPhotoToLocal,
  }) {
    return removePhotoFromLocal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetPhotos value)? getPhotos,
    TResult Function(_FetchPhotos value)? fetchPhotos,
    TResult Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult Function(_SetPhotoToLocal value)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (removePhotoFromLocal != null) {
      return removePhotoFromLocal(this);
    }
    return orElse();
  }
}

abstract class _RemovePhotoFromLocal implements PhotoEvent {
  const factory _RemovePhotoFromLocal({required final PhotoModel photo}) =
      _$_RemovePhotoFromLocal;

  PhotoModel get photo;
  @JsonKey(ignore: true)
  _$$_RemovePhotoFromLocalCopyWith<_$_RemovePhotoFromLocal> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$_SetPhotoToLocalCopyWith<$Res> {
  factory _$$_SetPhotoToLocalCopyWith(
          _$_SetPhotoToLocal value, $Res Function(_$_SetPhotoToLocal) then) =
      __$$_SetPhotoToLocalCopyWithImpl<$Res>;
  @useResult
  $Res call({PhotoModel photo});
}

/// @nodoc
class __$$_SetPhotoToLocalCopyWithImpl<$Res>
    extends _$PhotoEventCopyWithImpl<$Res, _$_SetPhotoToLocal>
    implements _$$_SetPhotoToLocalCopyWith<$Res> {
  __$$_SetPhotoToLocalCopyWithImpl(
      _$_SetPhotoToLocal _value, $Res Function(_$_SetPhotoToLocal) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? photo = null,
  }) {
    return _then(_$_SetPhotoToLocal(
      photo: null == photo
          ? _value.photo
          : photo // ignore: cast_nullable_to_non_nullable
              as PhotoModel,
    ));
  }
}

/// @nodoc

class _$_SetPhotoToLocal implements _SetPhotoToLocal {
  const _$_SetPhotoToLocal({required this.photo});

  @override
  final PhotoModel photo;

  @override
  String toString() {
    return 'PhotoEvent.setPhotoToLocal(photo: $photo)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SetPhotoToLocal &&
            (identical(other.photo, photo) || other.photo == photo));
  }

  @override
  int get hashCode => Object.hash(runtimeType, photo);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_SetPhotoToLocalCopyWith<_$_SetPhotoToLocal> get copyWith =>
      __$$_SetPhotoToLocalCopyWithImpl<_$_SetPhotoToLocal>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() getPhotos,
    required TResult Function() fetchPhotos,
    required TResult Function() getPhotosFromLocal,
    required TResult Function(PhotoModel photo) removePhotoFromLocal,
    required TResult Function(PhotoModel photo) setPhotoToLocal,
  }) {
    return setPhotoToLocal(photo);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? getPhotos,
    TResult? Function()? fetchPhotos,
    TResult? Function()? getPhotosFromLocal,
    TResult? Function(PhotoModel photo)? removePhotoFromLocal,
    TResult? Function(PhotoModel photo)? setPhotoToLocal,
  }) {
    return setPhotoToLocal?.call(photo);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? getPhotos,
    TResult Function()? fetchPhotos,
    TResult Function()? getPhotosFromLocal,
    TResult Function(PhotoModel photo)? removePhotoFromLocal,
    TResult Function(PhotoModel photo)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (setPhotoToLocal != null) {
      return setPhotoToLocal(photo);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_GetPhotos value) getPhotos,
    required TResult Function(_FetchPhotos value) fetchPhotos,
    required TResult Function(_GetPhotosFromLocal value) getPhotosFromLocal,
    required TResult Function(_RemovePhotoFromLocal value) removePhotoFromLocal,
    required TResult Function(_SetPhotoToLocal value) setPhotoToLocal,
  }) {
    return setPhotoToLocal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_GetPhotos value)? getPhotos,
    TResult? Function(_FetchPhotos value)? fetchPhotos,
    TResult? Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult? Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult? Function(_SetPhotoToLocal value)? setPhotoToLocal,
  }) {
    return setPhotoToLocal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_GetPhotos value)? getPhotos,
    TResult Function(_FetchPhotos value)? fetchPhotos,
    TResult Function(_GetPhotosFromLocal value)? getPhotosFromLocal,
    TResult Function(_RemovePhotoFromLocal value)? removePhotoFromLocal,
    TResult Function(_SetPhotoToLocal value)? setPhotoToLocal,
    required TResult orElse(),
  }) {
    if (setPhotoToLocal != null) {
      return setPhotoToLocal(this);
    }
    return orElse();
  }
}

abstract class _SetPhotoToLocal implements PhotoEvent {
  const factory _SetPhotoToLocal({required final PhotoModel photo}) =
      _$_SetPhotoToLocal;

  PhotoModel get photo;
  @JsonKey(ignore: true)
  _$$_SetPhotoToLocalCopyWith<_$_SetPhotoToLocal> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PhotoState {
  List<PhotoModel> get elements => throw _privateConstructorUsedError;
  List<PhotoModel> get favorites => throw _privateConstructorUsedError;
  Map<int, PhotoModel> get favoritesMap => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        base,
    required TResult Function(
            List<PhotoModel> elements,
            List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap,
            Exception exception)
        error,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        loading,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        fetching,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BasePhotoState value) base,
    required TResult Function(ErrorPhotoState value) error,
    required TResult Function(LoadingPhotoState value) loading,
    required TResult Function(FetchingPhotoState value) fetching,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BasePhotoState value)? base,
    TResult? Function(ErrorPhotoState value)? error,
    TResult? Function(LoadingPhotoState value)? loading,
    TResult? Function(FetchingPhotoState value)? fetching,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BasePhotoState value)? base,
    TResult Function(ErrorPhotoState value)? error,
    TResult Function(LoadingPhotoState value)? loading,
    TResult Function(FetchingPhotoState value)? fetching,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $PhotoStateCopyWith<PhotoState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PhotoStateCopyWith<$Res> {
  factory $PhotoStateCopyWith(
          PhotoState value, $Res Function(PhotoState) then) =
      _$PhotoStateCopyWithImpl<$Res, PhotoState>;
  @useResult
  $Res call(
      {List<PhotoModel> elements,
      List<PhotoModel> favorites,
      Map<int, PhotoModel> favoritesMap});
}

/// @nodoc
class _$PhotoStateCopyWithImpl<$Res, $Val extends PhotoState>
    implements $PhotoStateCopyWith<$Res> {
  _$PhotoStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? elements = null,
    Object? favorites = null,
    Object? favoritesMap = null,
  }) {
    return _then(_value.copyWith(
      elements: null == elements
          ? _value.elements
          : elements // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favorites: null == favorites
          ? _value.favorites
          : favorites // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favoritesMap: null == favoritesMap
          ? _value.favoritesMap
          : favoritesMap // ignore: cast_nullable_to_non_nullable
              as Map<int, PhotoModel>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BasePhotoStateCopyWith<$Res>
    implements $PhotoStateCopyWith<$Res> {
  factory _$$BasePhotoStateCopyWith(
          _$BasePhotoState value, $Res Function(_$BasePhotoState) then) =
      __$$BasePhotoStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<PhotoModel> elements,
      List<PhotoModel> favorites,
      Map<int, PhotoModel> favoritesMap});
}

/// @nodoc
class __$$BasePhotoStateCopyWithImpl<$Res>
    extends _$PhotoStateCopyWithImpl<$Res, _$BasePhotoState>
    implements _$$BasePhotoStateCopyWith<$Res> {
  __$$BasePhotoStateCopyWithImpl(
      _$BasePhotoState _value, $Res Function(_$BasePhotoState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? elements = null,
    Object? favorites = null,
    Object? favoritesMap = null,
  }) {
    return _then(_$BasePhotoState(
      elements: null == elements
          ? _value._elements
          : elements // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favorites: null == favorites
          ? _value._favorites
          : favorites // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favoritesMap: null == favoritesMap
          ? _value._favoritesMap
          : favoritesMap // ignore: cast_nullable_to_non_nullable
              as Map<int, PhotoModel>,
    ));
  }
}

/// @nodoc

class _$BasePhotoState extends BasePhotoState {
  const _$BasePhotoState(
      {required final List<PhotoModel> elements,
      required final List<PhotoModel> favorites,
      required final Map<int, PhotoModel> favoritesMap})
      : _elements = elements,
        _favorites = favorites,
        _favoritesMap = favoritesMap,
        super._();

  final List<PhotoModel> _elements;
  @override
  List<PhotoModel> get elements {
    if (_elements is EqualUnmodifiableListView) return _elements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_elements);
  }

  final List<PhotoModel> _favorites;
  @override
  List<PhotoModel> get favorites {
    if (_favorites is EqualUnmodifiableListView) return _favorites;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_favorites);
  }

  final Map<int, PhotoModel> _favoritesMap;
  @override
  Map<int, PhotoModel> get favoritesMap {
    if (_favoritesMap is EqualUnmodifiableMapView) return _favoritesMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_favoritesMap);
  }

  @override
  String toString() {
    return 'PhotoState.base(elements: $elements, favorites: $favorites, favoritesMap: $favoritesMap)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BasePhotoState &&
            const DeepCollectionEquality().equals(other._elements, _elements) &&
            const DeepCollectionEquality()
                .equals(other._favorites, _favorites) &&
            const DeepCollectionEquality()
                .equals(other._favoritesMap, _favoritesMap));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_elements),
      const DeepCollectionEquality().hash(_favorites),
      const DeepCollectionEquality().hash(_favoritesMap));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BasePhotoStateCopyWith<_$BasePhotoState> get copyWith =>
      __$$BasePhotoStateCopyWithImpl<_$BasePhotoState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        base,
    required TResult Function(
            List<PhotoModel> elements,
            List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap,
            Exception exception)
        error,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        loading,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        fetching,
  }) {
    return base(elements, favorites, favoritesMap);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
  }) {
    return base?.call(elements, favorites, favoritesMap);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
    required TResult orElse(),
  }) {
    if (base != null) {
      return base(elements, favorites, favoritesMap);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BasePhotoState value) base,
    required TResult Function(ErrorPhotoState value) error,
    required TResult Function(LoadingPhotoState value) loading,
    required TResult Function(FetchingPhotoState value) fetching,
  }) {
    return base(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BasePhotoState value)? base,
    TResult? Function(ErrorPhotoState value)? error,
    TResult? Function(LoadingPhotoState value)? loading,
    TResult? Function(FetchingPhotoState value)? fetching,
  }) {
    return base?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BasePhotoState value)? base,
    TResult Function(ErrorPhotoState value)? error,
    TResult Function(LoadingPhotoState value)? loading,
    TResult Function(FetchingPhotoState value)? fetching,
    required TResult orElse(),
  }) {
    if (base != null) {
      return base(this);
    }
    return orElse();
  }
}

abstract class BasePhotoState extends PhotoState {
  const factory BasePhotoState(
      {required final List<PhotoModel> elements,
      required final List<PhotoModel> favorites,
      required final Map<int, PhotoModel> favoritesMap}) = _$BasePhotoState;
  const BasePhotoState._() : super._();

  @override
  List<PhotoModel> get elements;
  @override
  List<PhotoModel> get favorites;
  @override
  Map<int, PhotoModel> get favoritesMap;
  @override
  @JsonKey(ignore: true)
  _$$BasePhotoStateCopyWith<_$BasePhotoState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorPhotoStateCopyWith<$Res>
    implements $PhotoStateCopyWith<$Res> {
  factory _$$ErrorPhotoStateCopyWith(
          _$ErrorPhotoState value, $Res Function(_$ErrorPhotoState) then) =
      __$$ErrorPhotoStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<PhotoModel> elements,
      List<PhotoModel> favorites,
      Map<int, PhotoModel> favoritesMap,
      Exception exception});
}

/// @nodoc
class __$$ErrorPhotoStateCopyWithImpl<$Res>
    extends _$PhotoStateCopyWithImpl<$Res, _$ErrorPhotoState>
    implements _$$ErrorPhotoStateCopyWith<$Res> {
  __$$ErrorPhotoStateCopyWithImpl(
      _$ErrorPhotoState _value, $Res Function(_$ErrorPhotoState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? elements = null,
    Object? favorites = null,
    Object? favoritesMap = null,
    Object? exception = null,
  }) {
    return _then(_$ErrorPhotoState(
      elements: null == elements
          ? _value._elements
          : elements // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favorites: null == favorites
          ? _value._favorites
          : favorites // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favoritesMap: null == favoritesMap
          ? _value._favoritesMap
          : favoritesMap // ignore: cast_nullable_to_non_nullable
              as Map<int, PhotoModel>,
      exception: null == exception
          ? _value.exception
          : exception // ignore: cast_nullable_to_non_nullable
              as Exception,
    ));
  }
}

/// @nodoc

class _$ErrorPhotoState extends ErrorPhotoState {
  const _$ErrorPhotoState(
      {required final List<PhotoModel> elements,
      required final List<PhotoModel> favorites,
      required final Map<int, PhotoModel> favoritesMap,
      required this.exception})
      : _elements = elements,
        _favorites = favorites,
        _favoritesMap = favoritesMap,
        super._();

  final List<PhotoModel> _elements;
  @override
  List<PhotoModel> get elements {
    if (_elements is EqualUnmodifiableListView) return _elements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_elements);
  }

  final List<PhotoModel> _favorites;
  @override
  List<PhotoModel> get favorites {
    if (_favorites is EqualUnmodifiableListView) return _favorites;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_favorites);
  }

  final Map<int, PhotoModel> _favoritesMap;
  @override
  Map<int, PhotoModel> get favoritesMap {
    if (_favoritesMap is EqualUnmodifiableMapView) return _favoritesMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_favoritesMap);
  }

  @override
  final Exception exception;

  @override
  String toString() {
    return 'PhotoState.error(elements: $elements, favorites: $favorites, favoritesMap: $favoritesMap, exception: $exception)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorPhotoState &&
            const DeepCollectionEquality().equals(other._elements, _elements) &&
            const DeepCollectionEquality()
                .equals(other._favorites, _favorites) &&
            const DeepCollectionEquality()
                .equals(other._favoritesMap, _favoritesMap) &&
            (identical(other.exception, exception) ||
                other.exception == exception));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_elements),
      const DeepCollectionEquality().hash(_favorites),
      const DeepCollectionEquality().hash(_favoritesMap),
      exception);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorPhotoStateCopyWith<_$ErrorPhotoState> get copyWith =>
      __$$ErrorPhotoStateCopyWithImpl<_$ErrorPhotoState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        base,
    required TResult Function(
            List<PhotoModel> elements,
            List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap,
            Exception exception)
        error,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        loading,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        fetching,
  }) {
    return error(elements, favorites, favoritesMap, exception);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
  }) {
    return error?.call(elements, favorites, favoritesMap, exception);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(elements, favorites, favoritesMap, exception);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BasePhotoState value) base,
    required TResult Function(ErrorPhotoState value) error,
    required TResult Function(LoadingPhotoState value) loading,
    required TResult Function(FetchingPhotoState value) fetching,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BasePhotoState value)? base,
    TResult? Function(ErrorPhotoState value)? error,
    TResult? Function(LoadingPhotoState value)? loading,
    TResult? Function(FetchingPhotoState value)? fetching,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BasePhotoState value)? base,
    TResult Function(ErrorPhotoState value)? error,
    TResult Function(LoadingPhotoState value)? loading,
    TResult Function(FetchingPhotoState value)? fetching,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class ErrorPhotoState extends PhotoState {
  const factory ErrorPhotoState(
      {required final List<PhotoModel> elements,
      required final List<PhotoModel> favorites,
      required final Map<int, PhotoModel> favoritesMap,
      required final Exception exception}) = _$ErrorPhotoState;
  const ErrorPhotoState._() : super._();

  @override
  List<PhotoModel> get elements;
  @override
  List<PhotoModel> get favorites;
  @override
  Map<int, PhotoModel> get favoritesMap;
  Exception get exception;
  @override
  @JsonKey(ignore: true)
  _$$ErrorPhotoStateCopyWith<_$ErrorPhotoState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadingPhotoStateCopyWith<$Res>
    implements $PhotoStateCopyWith<$Res> {
  factory _$$LoadingPhotoStateCopyWith(
          _$LoadingPhotoState value, $Res Function(_$LoadingPhotoState) then) =
      __$$LoadingPhotoStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<PhotoModel> elements,
      List<PhotoModel> favorites,
      Map<int, PhotoModel> favoritesMap});
}

/// @nodoc
class __$$LoadingPhotoStateCopyWithImpl<$Res>
    extends _$PhotoStateCopyWithImpl<$Res, _$LoadingPhotoState>
    implements _$$LoadingPhotoStateCopyWith<$Res> {
  __$$LoadingPhotoStateCopyWithImpl(
      _$LoadingPhotoState _value, $Res Function(_$LoadingPhotoState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? elements = null,
    Object? favorites = null,
    Object? favoritesMap = null,
  }) {
    return _then(_$LoadingPhotoState(
      elements: null == elements
          ? _value._elements
          : elements // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favorites: null == favorites
          ? _value._favorites
          : favorites // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favoritesMap: null == favoritesMap
          ? _value._favoritesMap
          : favoritesMap // ignore: cast_nullable_to_non_nullable
              as Map<int, PhotoModel>,
    ));
  }
}

/// @nodoc

class _$LoadingPhotoState extends LoadingPhotoState {
  const _$LoadingPhotoState(
      {required final List<PhotoModel> elements,
      required final List<PhotoModel> favorites,
      required final Map<int, PhotoModel> favoritesMap})
      : _elements = elements,
        _favorites = favorites,
        _favoritesMap = favoritesMap,
        super._();

  final List<PhotoModel> _elements;
  @override
  List<PhotoModel> get elements {
    if (_elements is EqualUnmodifiableListView) return _elements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_elements);
  }

  final List<PhotoModel> _favorites;
  @override
  List<PhotoModel> get favorites {
    if (_favorites is EqualUnmodifiableListView) return _favorites;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_favorites);
  }

  final Map<int, PhotoModel> _favoritesMap;
  @override
  Map<int, PhotoModel> get favoritesMap {
    if (_favoritesMap is EqualUnmodifiableMapView) return _favoritesMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_favoritesMap);
  }

  @override
  String toString() {
    return 'PhotoState.loading(elements: $elements, favorites: $favorites, favoritesMap: $favoritesMap)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadingPhotoState &&
            const DeepCollectionEquality().equals(other._elements, _elements) &&
            const DeepCollectionEquality()
                .equals(other._favorites, _favorites) &&
            const DeepCollectionEquality()
                .equals(other._favoritesMap, _favoritesMap));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_elements),
      const DeepCollectionEquality().hash(_favorites),
      const DeepCollectionEquality().hash(_favoritesMap));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadingPhotoStateCopyWith<_$LoadingPhotoState> get copyWith =>
      __$$LoadingPhotoStateCopyWithImpl<_$LoadingPhotoState>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        base,
    required TResult Function(
            List<PhotoModel> elements,
            List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap,
            Exception exception)
        error,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        loading,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        fetching,
  }) {
    return loading(elements, favorites, favoritesMap);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
  }) {
    return loading?.call(elements, favorites, favoritesMap);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(elements, favorites, favoritesMap);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BasePhotoState value) base,
    required TResult Function(ErrorPhotoState value) error,
    required TResult Function(LoadingPhotoState value) loading,
    required TResult Function(FetchingPhotoState value) fetching,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BasePhotoState value)? base,
    TResult? Function(ErrorPhotoState value)? error,
    TResult? Function(LoadingPhotoState value)? loading,
    TResult? Function(FetchingPhotoState value)? fetching,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BasePhotoState value)? base,
    TResult Function(ErrorPhotoState value)? error,
    TResult Function(LoadingPhotoState value)? loading,
    TResult Function(FetchingPhotoState value)? fetching,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class LoadingPhotoState extends PhotoState {
  const factory LoadingPhotoState(
      {required final List<PhotoModel> elements,
      required final List<PhotoModel> favorites,
      required final Map<int, PhotoModel> favoritesMap}) = _$LoadingPhotoState;
  const LoadingPhotoState._() : super._();

  @override
  List<PhotoModel> get elements;
  @override
  List<PhotoModel> get favorites;
  @override
  Map<int, PhotoModel> get favoritesMap;
  @override
  @JsonKey(ignore: true)
  _$$LoadingPhotoStateCopyWith<_$LoadingPhotoState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FetchingPhotoStateCopyWith<$Res>
    implements $PhotoStateCopyWith<$Res> {
  factory _$$FetchingPhotoStateCopyWith(_$FetchingPhotoState value,
          $Res Function(_$FetchingPhotoState) then) =
      __$$FetchingPhotoStateCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<PhotoModel> elements,
      List<PhotoModel> favorites,
      Map<int, PhotoModel> favoritesMap});
}

/// @nodoc
class __$$FetchingPhotoStateCopyWithImpl<$Res>
    extends _$PhotoStateCopyWithImpl<$Res, _$FetchingPhotoState>
    implements _$$FetchingPhotoStateCopyWith<$Res> {
  __$$FetchingPhotoStateCopyWithImpl(
      _$FetchingPhotoState _value, $Res Function(_$FetchingPhotoState) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? elements = null,
    Object? favorites = null,
    Object? favoritesMap = null,
  }) {
    return _then(_$FetchingPhotoState(
      elements: null == elements
          ? _value._elements
          : elements // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favorites: null == favorites
          ? _value._favorites
          : favorites // ignore: cast_nullable_to_non_nullable
              as List<PhotoModel>,
      favoritesMap: null == favoritesMap
          ? _value._favoritesMap
          : favoritesMap // ignore: cast_nullable_to_non_nullable
              as Map<int, PhotoModel>,
    ));
  }
}

/// @nodoc

class _$FetchingPhotoState extends FetchingPhotoState {
  const _$FetchingPhotoState(
      {required final List<PhotoModel> elements,
      required final List<PhotoModel> favorites,
      required final Map<int, PhotoModel> favoritesMap})
      : _elements = elements,
        _favorites = favorites,
        _favoritesMap = favoritesMap,
        super._();

  final List<PhotoModel> _elements;
  @override
  List<PhotoModel> get elements {
    if (_elements is EqualUnmodifiableListView) return _elements;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_elements);
  }

  final List<PhotoModel> _favorites;
  @override
  List<PhotoModel> get favorites {
    if (_favorites is EqualUnmodifiableListView) return _favorites;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_favorites);
  }

  final Map<int, PhotoModel> _favoritesMap;
  @override
  Map<int, PhotoModel> get favoritesMap {
    if (_favoritesMap is EqualUnmodifiableMapView) return _favoritesMap;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_favoritesMap);
  }

  @override
  String toString() {
    return 'PhotoState.fetching(elements: $elements, favorites: $favorites, favoritesMap: $favoritesMap)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FetchingPhotoState &&
            const DeepCollectionEquality().equals(other._elements, _elements) &&
            const DeepCollectionEquality()
                .equals(other._favorites, _favorites) &&
            const DeepCollectionEquality()
                .equals(other._favoritesMap, _favoritesMap));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_elements),
      const DeepCollectionEquality().hash(_favorites),
      const DeepCollectionEquality().hash(_favoritesMap));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FetchingPhotoStateCopyWith<_$FetchingPhotoState> get copyWith =>
      __$$FetchingPhotoStateCopyWithImpl<_$FetchingPhotoState>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        base,
    required TResult Function(
            List<PhotoModel> elements,
            List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap,
            Exception exception)
        error,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        loading,
    required TResult Function(List<PhotoModel> elements,
            List<PhotoModel> favorites, Map<int, PhotoModel> favoritesMap)
        fetching,
  }) {
    return fetching(elements, favorites, favoritesMap);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult? Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
  }) {
    return fetching?.call(elements, favorites, favoritesMap);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        base,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap, Exception exception)?
        error,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        loading,
    TResult Function(List<PhotoModel> elements, List<PhotoModel> favorites,
            Map<int, PhotoModel> favoritesMap)?
        fetching,
    required TResult orElse(),
  }) {
    if (fetching != null) {
      return fetching(elements, favorites, favoritesMap);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(BasePhotoState value) base,
    required TResult Function(ErrorPhotoState value) error,
    required TResult Function(LoadingPhotoState value) loading,
    required TResult Function(FetchingPhotoState value) fetching,
  }) {
    return fetching(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(BasePhotoState value)? base,
    TResult? Function(ErrorPhotoState value)? error,
    TResult? Function(LoadingPhotoState value)? loading,
    TResult? Function(FetchingPhotoState value)? fetching,
  }) {
    return fetching?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(BasePhotoState value)? base,
    TResult Function(ErrorPhotoState value)? error,
    TResult Function(LoadingPhotoState value)? loading,
    TResult Function(FetchingPhotoState value)? fetching,
    required TResult orElse(),
  }) {
    if (fetching != null) {
      return fetching(this);
    }
    return orElse();
  }
}

abstract class FetchingPhotoState extends PhotoState {
  const factory FetchingPhotoState(
      {required final List<PhotoModel> elements,
      required final List<PhotoModel> favorites,
      required final Map<int, PhotoModel> favoritesMap}) = _$FetchingPhotoState;
  const FetchingPhotoState._() : super._();

  @override
  List<PhotoModel> get elements;
  @override
  List<PhotoModel> get favorites;
  @override
  Map<int, PhotoModel> get favoritesMap;
  @override
  @JsonKey(ignore: true)
  _$$FetchingPhotoStateCopyWith<_$FetchingPhotoState> get copyWith =>
      throw _privateConstructorUsedError;
}
